= Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title: An Overview of the Developer Guide:
:imagesDir: images
:stylesDir: stylesheets
:experimental:

== 1 Introduction
The MediBook v1.4 is an application that function as an advance logbook for in healthcare settings. It allows healthcare professionals to keep track of patients’ details, arrange their schedule based on their patients’ appointments and communicate efficiently between colleagues through instant messaging.

This Developer Guide is intended for users with basic technical background as it details the setting up of our application, the design of our software architecture, describe the implementation of our key features, and the testing involved in our software. Appendix includes user stories and use case for reference.


== 2 Setting up

=== Prerequisites

* JDK 9 or later
* IntelliJ IDE

=== Importing the project into IntelliJ

. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. If JDK 9 is listed in the drop down, select it. If it is not, click `New...` and select the directory where you installed JDK 9
.. Click `OK`
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Run the `seedu.addressbook.Main` class (right-click the `Main` class and click `Run Main.main()`) and try executing a few commands
. Run all the tests (right-click the `test` folder, and click `Run 'All Tests'`) and ensure that they pass
. Open the `StorageFile` file and check for any code errors
.. Due to an ongoing https://youtrack.jetbrains.com/issue/IDEA-189060[issue] with some of the newer versions of IntelliJ, code errors may be detected even if the project can be built and run successfully
.. To resolve this, place your cursor over any of the code section highlighted in red. Press kbd:[ALT + ENTER], and select `Add '--add-modules=java.xml.bind' to module compiler options`


== 3 Design

image::mainClassDiagram.png[]

=== 3.2 Logic Component

image::LogicComponentClassDiagram.png[]

== 4. Implementation
This section describes some noteworthy details on how certain features are implemented.
// tag::statecontrol[]
=== 4.1  State control (undo/redo)
The state control feature allows the user to manipulate the different states of the MediBook in the current session with the undo and redo command. This section will describe the implementation of this feature.

==== 4.1.1  Current implementation

The state control mechanism is managed by the CommandStack class. It supports the undo-ing and redo-ing of commands that modifies the contents of the MediBook in the current session.

These commands will extend from `UndoAbleCommand` instead of `Command`. These commands are then managed by the *undoStack* and the *redoStack*.
The following diagram shows the inheritance diagram for commands:

image::UndoAbleCommand.png[]

Commands that inherits from `Command` are implemented this way:
[source, java]
----
public class FindCommand extends Command {
    @Override
    public CommandResult execute() {
        //Find Logic
    }
    //...more code...
}
----

On the other hand, commands that inherit from UndoAbleCommand are implemented this way:
[source, java]
----
public class ClearCommand extends UndoAbleCommand {
    @Override
    public CommandResult execute() {
        //Clear Logic
    }

    @Override
    public void executeUndo() {
        //Logic to undo clear
    }

    @Override
    public void executeRedo() {
        //Logic to redo clear
    }
    //...more code...
}
----
As shown, the commands that extends from the UndoAbleCommand will need to know how to undo and redo the changes they have made. This requires the object to store information of the change made. For example the DeleteCommand object will need store the person that was deleted so that the change made can be undone.

*The following core methods are in place to assist the mechanism:*

* `*undoLast()*`- Undo the command at the top of the *undoStack* and push it to the *redoStack* +
* `*redoLast()*`- Redo the command at the top of the *redoStack* and push it to the *undoStack* +
* `*truncateOldPath()*`- Clears the *redoStack* following a change made after undo-ing. +
* `*addCommandToStack()*`- Push an UndoAbleCommand into the command stack +
* `*checkForAction()*`- Check whether the `truncateOldPath()` method needs to be called before calling `addCommandToStack()`. +

*Below is an example usage scenario and the behaviours of the component at a given time:*

*1. On start-up:*

CommandStack will be initialised with an empty `undoStack` and `redoStack`.

image::statecontrolimple1.jpg[]

*2. User executes a command that make changes to the MediBook (e.g add John Doe...):*

The `add` command will do a`*commandStack.checkForAction()*` and subsequently `*addCommandToStack()*` which adds the AddCommand object into the `undoStack`.

image::statecontrolimple2.png[]

[NOTE]
`*commandStack.checkForAction()*` will only be called if the command has been executed successfully. If it fails its execution, the object will not be pushed into the `undoStack`.

*3. User executes another command that make changes to the MediBook (e.g delete 1):*

The same procedures as step 2 applies and the new `DeleteCommand` will be pushed into the `undoStack` on top of the previous `AddCommand` object.

image::statecontrolimple3.png[]

*4. User wants to undo the change they just made and executes the `undo` command:*

The undo command calls `*commandHistory.undoLast()*` which will get the object at the top of the `undoStack`, call its `executeUndo()` method, push it into the `redoStack` and then remove it from the undoStack.

image::statecontrolimple4.png[]

[NOTE]
If the user execute `undo` command when the `undoStack` is empty, the `*undoLast()*` method will throw a `*HistoryOutOfBoundException()*` which will be caught in the UndoCommand class and will display an error to the user instead.

*5. User executes another command that make changes to the MediBook after the undo (e.g clear):*

The `clear` command calls `*commandStack.checkForAction()*` which determines that this command was made following an `undo` command and therefore requires `*truncateOldPath()*` to be called. In this case, the `redoStack` will be cleared before the ClearCommand object is pushed into the `undoStack`.

image::statecontrolimple5.png[]

==== 4.1.2  Reason for this implementation
Storing the different states of the MediBook is relatively easy to implement and it is less prone to errors. However, a drawback for this implementation is the high memory usage required which might cause performance issues.

==== 4.1.3  Alternative consideration
An alternative to the current implementation is to save the list of commands executed in the arraylist instead of the whole MediBook and reverse them when attempting to undo. However, this requires implemented class to know how to reverse each command. For example, undo-ing a `delete` command requires the class to perform `add` and the class has to remember all the arguments required to create the same person that was deleted.
// end::statecontrol[]
=== 4.2 Login System
Securely logs user on to MediBook

==== 4.2.1 Current Implementation
Login is implemented before the main GUI launches. Upon the launch of MediBook, MediBook prompts for two input from the User, username and password. MediBook then compares the given pair of inputs with loginstorage.txt.

loginstorage.txt stores the username of all users and the hashes of their passwords. MediBook iterates through loginstorage.txt to find the matching username, and the corresponding hashed password. The password entered is hashed using Java’s SHA-512 hashing algorithm. The result is then matched with the hash stored in loginstorage.txt, if both matches then login is successful and user is allowed into MediBook. If they do not match, then the program is terminated.

==== 4.2.2 Reason for this implementation
There is no need to open the GUI, if User fails to log in, thus login is implemented before the GUI launches.
To ensure a secure MediBook, user login profiles must be stored securely. Storing the hash result instead of the password ensures that should loginstorage.txt be compromised, the actual passwords are still unknown to the perpetrators.

==== 4.2.3 Alternative consideration
Java Authentication and Authorisation System (JAAS) was also considered when deciding on how to implement MediBook’s login system. However, using JAAS is more restrictive than the current implementation which allows for easy change in hashing algorithms used and different security features in the future. JAAS is also harder to implement and as MediBook is currently targeted at about 1000 users, there is no need to use JAAS.


=== 4.3 Scheduling
Scheduling allows appointment to be stored in MediBook. The MediBook recognise a schedule date with the tag 'd/'.

==== 4.3.1 Current Implementation
The schedule feature currently accepts dates from the users as an input category under the add command. Input must be in the format DD-MM-YYYY for it to be accepted as a proper schedule date input. For each person added, multiple schedule dates can be added and it is also not a compulsory field to fill.

This is achieved by setting up a schedule class which sets a regular expression (regex) that only accept valid dates in the DD-MM-YYYY format. Non-existent dates such as 30-02-2019 or 28-28-2019 would not be accepted.

Subsequently, a hashset of schedule act as an attribute for person class. Every time the add command is used to add a valid person, a person object is created with the set of schedule as part of the attribute of the person. As such, there can be multiple appointment dates added together with the person. The schedule is identified using the ‘d/’ mark.

==== 4.3.2 Reason for Implementation
Due to the large number of patients the doctors care for, it is at times hard to keep track of the numerous appointments made by their patients. As such, a scheduling feature would record the appointment date so that they can keep track of the numerous appointments they have for the day.

==== 4.3.3 Future/Alternative Implementation
In future versions, the following details would be slowly incremented to ensure a smooth user experience while using the scheduling feature of MediBook.

. Edit the appointment dates only.
. A command to view all or list the appointments in a chronological order following the reference date.
. A doctor can view their respective patients appointment

==== 4.4 Instant Messaging
Once fully implemented, users will be able to chat over the internet using a separate chat client.

Instant messaging is implemented using a Swing-based client for the chat server.
Graphically it is a frame with a text field for entering messages and a text area to see the whole dialog.
The client follows the Chat Protocol which is as follows.

When the server sends "SUBMITNAME" the client replies with the desired screen name.  The server will keep sending "SUBMITNAME" requests as long as the client submits screen names that are already in use.
When the server sends a line beginning with "NAMEACCEPTED" the client is now allowed to startsending the server arbitrary strings to be broadcast to all chatters connected to the server.
When the server sends a line beginning with "MESSAGE " then all characters following this string should be displayed in its message area.

== 5.Testing
Testing the MediBook is important as it verifies that the MediBook is functioning and up-to-date. This can be done so by going into IntelliJ, right-click on the test folder and choose Run 'All Tests'.


[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="100%",cols="22%,<23%,<25%,<30%",options="header",]
|===========================================================================================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App
|`* * *` |user |my account to only be accessed by me |ensure my information and schedule is only edited by myself
|`* * *` |user |To be able to update or recover my password |Access my account even if I forgot my password and keep my credentials secure
|`* * *` |user |add a new person |
|`* * *` |user |delete a person |remove entries that I no longer need
|`* * *` |user |find a person by name |locate details of persons without having to go through the entire list
|`* * *` |user |undo/redo changes made |revert changes that are unwanted
|`* *` |user |hide <<private-contact-detail, private contact details>> by default |minimize chance of someone else seeing them by accident
|`*` |user with many persons in the MediBook |sort persons by name |locate a person easily
|`*` |user |see history of commands made |identify changes that were made to the MediBook
|===========================================================================================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `MediBook` and the *Actor* is the `user`, unless specified otherwise)

=== Use case: UC01 - Login

*MSS*

. User opens up MediBook
. MediBook prompts for user to enter Username and Password
. User keys in Username and Password
. Login is successful, program continues.
. Use case ends.

*Extensions*

* 3a. Given set of Username and Password do not match any records
** 3a1 MediBook requests for Username and Password again
** 3a2 User keys in Username and Password
** 3a3 Correct Username and Password is entered, use case resumes from step 4
** Steps 3a1 - 3a2 are repeated for a maximum of two times or until a matching set of Username and Password is entered
** If Username and Password still incorrect, program terminates
+
Use case ends.

=== Use case: UC02 - Determine Access Level

*MSS*

. User logs in to MediBook (UC01)
. MediBook will look up the corresponding access level of User
. Based on the designated access level of the User, various viewing and editing rights will be handed to User
+
Use case ends.

=== Use case: UC03 - Information Confidentiality

*MSS*

. User logs in to MediBook (UC01)
. MediBook determines access level of User (UC02)
. MediBook will display information that User has access to and hide information that is beyond User’s access level
+
Use case ends.

=== Use case: Delete person

*MSS*

. User requests to list persons
. MediBook shows a list of persons
. User requests to delete a specific person in the list
. MediBook deletes the person.
+
Use case ends.

*Extensions*

* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
** 3a1. MediBook shows an error message.
+
Use case resumes at step 2.

[appendix]
== Non Functional Requirements

. Should work on any <<mainstream-os, mainstream OS>> as long as it has Java 9 or higher installed.
. Should be able to hold up to 1000 persons.
. Should come with automated unit tests and open source code.
. Should favor DOS style commands over Unix-style commands.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[private-contact-detail]] Private contact detail::
A contact detail that is not meant to be shared with others.
